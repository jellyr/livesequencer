* file load / save

* precise ALSA timing
  For precise timing it is certainly better
  to send ALSA events with future time stamps.
  Currently we wait using ALSA echo events
  and then send the actual event immediately.
  The proposed change increases latency of changes in the source files.

* allocate multiple ALSA ports and extend the Channel constructor by a port field
  Multiple ports allow to connect to different ALSA nodes
  and feed them with individual data.
  This is more easily done than distinction using MIDI channels.

* use haskell-src(-exts) for parsing, to be sure
  we have a subset of haskell

* highlight "the data (Number) that is
  currently being output" in the editor

* compositional highlighting
  The composition of note streams shall also compose their highlighting animations.
  Currently active terms are highlighted during a Wait event,
  but those Wait events are shortened by 'merge'.
  Actually, all active terms should only be highlighted
  for an infinitesimally short time.
  For music highlighting we could highlight terms from NoteOn to corresponding NoteOff.

* add a type checker to the implementation
  (and data declarations to the language)

* check all head, read, error, unmatched patterns, print, putStr stderr,
  toProgram, toPitch, toVelocity etc.
  whether they should handle exceptions

* handle for resizing parts of the window
  even better: a way for rearranging parts of the GUI
  this would allow to arrange text fields horizontally
  such as required for wide aspect in YouTube movies

* bug: when changing a module you might remove a term,
  that is still present in the reduced term
  In this case, the highlighter will highlight its original position.
  Reproduce it by: delete the 'repeat' in Simplesong and refresh -
  the former position of merge is highlighted

* cabal test:
  check whether modules in 'data' can be parsed by our parser
  check whether modules in 'data' directory can be compiled by GHC

* default path for data files
  Option.importPaths deflt should contain the paths from the Paths module.
  This makes working with an installation from Hackage easy,
  but makes working in the GIT working copy awful,
  because after every change in data/ you have to reinstall the files.



