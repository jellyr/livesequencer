* Module management:
  allow to start sequencer without any module, or only with Prelude, or only with Main
  allow to start sequencer with non-existing module and then present an empty module
      (http://dfa.imn.htwk-leipzig.de/bugzilla/show_bug.cgi?id=298)
  flush unimported modules
      compute the transitive import closure for the current module
      and remove the remaining modules

* rename module - rename imports?
  When renaming a module it would simplify editing a lot,
  if also imports would be changed.
  Changing the module in the interpreter is relatively easy,
  since it is already parsed.
  We know the source position of identifiers,
  thus it is possible to replace the identifiers in the interpreted module's source
  and thus we could update the display of the interpreted module.
  However modifications in the interpreted module
  will be lost on the next module refresh.
  Thus we must alter the edited module too.
  But the edited module may not be syntactically correct.
  We may only parse the preamble.
  Or we may only parse the longest prefix that is a correct preamble.
  And I think we must do the modification immediately in the GUI
  in order to make it atomically.

* read-only TVar program for interpreter
  We could define a wrapper around TVar that allows only reading.
  This should be used for the interpreter.

* Controllers should not be in an extra module
  It is difficult too maintain:
  We have to disable refreshing, renaming and closing of the Control module.
  We have to update the module when the user adds or removes checkBox calls in a module.
  It forbids to load the modules into GHCi.

  I think we should just use plain variable definitions
  and tag them with a pragma or with special naming scheme.
  The assigned value should be the default value.
  Is it a good idea to change the assigned value in the highlighter window
      when the value is changed?

  Like so:
  interactiveBool = False ;

  A pragma would allow to specify parameters.

  {-# INTERACTIVE Checkbox #-}
  bool = False ;

  {-# INTERACTIVE Slider #-}
  modulation = 0 ;

  {-# INTERACTIVE MIDI Controller 0 7 #-}
  volume = 64 ;

  Alternatively we keep checkBox and similar functions,
  and tag their calls uniquely.
  Every call should be associated with a GUI element.
  However then it is not clear how to update GUI elements
  on a module refresh.
  We might combine both approaches as follows:

  {-# INTERACTIVE #-}
  bool = checkBox False ;

  {-# INTERACTIVE #-}
  modulation = slider 0 127 0 ;

  {-# INTERACTIVE #-}
  volume = midiController 0 7 64 ;

  Then setup a dummy module Control:
  checkBox :: Bool -> Bool
  checkBox = id

  This definition takes effect if you do not declare the pragma.

  However handling pragmas is not easy, too.
  How to cope with multiple defining equations?
  How about this one:

  bool = interactive "bool" ( checkBox False ) ;
  modulation = interactive "modulation" ( slider 0 127 0 ) ;
  volume = interactive "volume" ( midiController 0 7 64 ) ;

  Or we leave it almost as it is and
  replace the constructors that identify controllers by plain strings.

  In any case the Module record needs a 'controllers' field
  and the controllers must be updated at every module refresh.

* Module system:
  support qualification and all styles of imports
  when refreshing a module, I think we need a global check of all imports
  check for existence of imported and used qualifiers
  export lists
  hierarchical module names

* avoid denial of service attacks
  refuse too many events in a short time period,
      caused by missing, short or invalid Waits
      e.g.:
          main = [ Wait Invalid ] ++ main
          main = [ Event bla ] ++ main
  restrict the size of the current term
      and thus prevent memory leaks
  restrict the number of reduction per element
      in order to prevent infinite loops

* The current term is actually not current,
  it shows the last state.
  This is a problem, when we apply a function to the current term,
  since then suddenly a different term pops up.
  It may become even more a problem,
  when we allow more fine-grained reduction steps.
  We could thus divide the current term into the 'head' and the 'tail'.
  Maybe we can even display 'head' and 'tail' separately.
  In a left sub-window we could list all emitted events
  and a right sub-window we could show the real current term.

* move to new explicit-exception version and use its Exc.switchT

* Exception
  move from other modules to Exception module:
  excT, switchT, dummyRange, inoutExceptionMsg ...

* Library part
  Move modules into module hierarchy.

* pair syntax (a,b)
  We could make "," a regular infix operator with low precendence.
  This would give us operator section syntax.
  However it conflicts with commas in list syntax.
  We should just let the Helium parser solve this problem.

* Are newlines in module content from HTTP handled correctly?
  WWW uses CR+LF
  I have observed, that Windows/InternetExplorer submits CR+LF in the modified text lines.
  The question is, what kind of line end is expected by WxWidgets?

* higher order functions:
  support operator sections like (+) and (:)
    Can expressions like (a+) and (+b) be handled by postfix and prefix operators?
    This won't work, because operator sections are only allowed in parentheses.
    E.g. (a + + b) is not valid syntax.
    However it is allowed to write (a+b+).
    But due to the left-associativity it is not allowed to write (+a+b).
    Is it allowed to use the same operator as infix and postfix symbol?
    Maybe at the beginning I should only support (+), but not (a+) and (+a).
    Since operator section is only allowed in parentheses
       we can handle it in the parser of syntactic atoms.
  support lambda

* Gtk-CRITICAL warnings: eliminate them
  sometimes the program crashes on exit

* GUI graphical error:
  between menu and tab handles there is a short line,
    that looks like the top border of another handle
  does it have a meaning?

* precise ALSA timing
  For precise timing it is certainly better
  to send ALSA events with future time stamps.
  Currently we wait using ALSA echo events
  and then send the actual event immediately.
  The proposed change increases latency of changes in the source files.
  Current term and highlighting should be updated
  when the delayed MIDI event is played.
  We can achieve this by sending an Echo message to ourselves.
  We already send Echo messages to ourselves.
  We should use two kinds of Echo messages:
  One of them triggers evaluation, the other one triggers visualization
  and has the same time stamp as the according ALSA time stamp.
  We need to start and stop queues with the same latency.
  .
  We can even hide the latency by starting the computation non-stop
  until the timestamps of the computed events are
  sufficiently ahead of the actual current time.
  When we stop the queue this will also happen instantly.

* PortMidi support
  We could fall back to threadDelay timing
  and WX-timer event for polling incoming MIDI keys.
  We could even achieve precise timing with PortMidi
  using PortMidi's latency, rough waiting using threadDelay
  and synchronization using PortTime's 'time' function.

* Dirk Richter proposes to store old module contents when updating a module.
  This way you can later reproduce what you did in a live performance.

* use haskell-src(-exts) for parsing,
  to be sure we have a subset of haskell
  haskell-src: no support for precedence and associativity
  haskell-src-ext: no support for source locations
  better: Helium parser supports all we need

* Can we use reactive-banana-wx in order to write safer GUI?
  Maybe we can simplify:
     mutual exclusive menu items
     consistency Map Module.Name Page with GUI pages
     synchronization of ALSA and WX and HTTP,
        e.g. various inputs to the text field; execution modes
  Peter Pepper: "Acausal programming"

* demand trace/"backtrace"/GUI:
  distinguish between musical and operational highlighting
  as described below, highlighting according to NoteOn and NoteOff won't work
  and it would also not solve the problem of dependencies
  We could maintain a map of currently played notes
     in order to switch off highlighting for these notes,
     when NoteOff is send.
     This would correctly de-highlight notes,
     but the backtrace would still be cumulative.
  Interesting observation:
     in a 'repeat' the last notes are turned back to normal appearance
     if the loop starts again

* compositional highlighting
  The composition of note streams shall also compose their highlighting animations.
  Currently active terms are highlighted during a Wait event,
  but those Wait events are shortened by 'merge'.
  Actually, all active terms should only be highlighted
  for an infinitesimally short time.
  For music highlighting we could highlight terms from NoteOn to corresponding NoteOff.
  This would not work -
  if NoteOn is wrapped in f and NoteOff is wrapped in g,
  then on NoteOn the highlighting of f is switched on
  and on NoteOff the highlighting of g is switched off?
  Instead I think we must highlight the complete "backtrace" for the active term
  (or at least the Wait, since this is what we really show)

* merge editor and highlighter window
  track all inputs of the editor window and
  adapt the information in the syntax tree accordingly
  I am not sure that this is an advantage.
  Maybe there should be two windows:
  One with the editor and one with the interpreter content and the current term.
  This way you can project the interpreter content to the wall
  and edit in the editor privately.

* Maybe we should use WxWidgets feature for external GUI description.
  This way, the user can choose the arrangement
  of editor, highlighter and current term area.
  We could also have translated versions without recompilation.

* add a type checker to the implementation
  Try to incorporate Helium/parser/type-checker or Typing Haskell in Haskell.
  Can one of the special Haskell editors Yi or Leksah be of help?

* support different import modes, qualified identifiers
  and clashing identifiers in modules
  Only this way, several people can work independently in their modules.

* check all head, read, error, unmatched patterns, irrefutable patterns, print, putStr stderr,
  toProgram, toPitch, toVelocity,
  readFile, writeFile and other IO functions,
  whether they should handle exceptions
  especially in Program there are currently too many 'errors'
  problem: there will be no warnings about patterns in monadic results
      e.g. (Number rng n) <- top

* handle for resizing parts of the window
  even better: a way for rearranging parts of the GUI
  this would allow to arrange text fields horizontally
  such as required for wide aspect in YouTube movies

* bug: when changing a module you might remove a term,
  that is still present in the reduced term
  In this case, the highlighter will highlight its original position.
  Reproduce it by: delete the 'repeat' in Simplesong and refresh -
  the former position of merge is highlighted

* cabal test:
  check whether modules in 'data' can be parsed by our parser
  check whether modules in 'data' directory can be compiled by GHC

* maybe split Term into Parser and Term module

* allow IO or restricted IO monad
    such that the live program can send the messages itself

* single step mode: allow finer steps
  For finer steps we have to break the recursion and remember the application focus.
  How to do this?
  Using a Zipper on the Term?
  Using a Map Id Node and an Id that points to the focus?
  Do not represent a focus but extend the Term tree
    such that each node contains a sequence of reductions.
    Flattening all sequences should give a sequence of term trees.
    Since the flattening is lazy,
    we can decide later what information to present to the user.
    We could even reverse steps back to the last sent event.
