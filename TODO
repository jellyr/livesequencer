
* precise ALSA timing
  For precise timing it is certainly better
  to send ALSA events with future time stamps.
  Currently we wait using ALSA echo events
  and then send the actual event immediately.
  The proposed change increases latency of changes in the source files.

* allocate multiple ALSA ports and extend the Channel constructor by a port field
  Multiple ports allow to connect to different ALSA nodes
  and feed them with individual data.
  This is more easily done than distinction using MIDI channels.

* use haskell-src(-exts) for parsing,
  to be sure we have a subset of haskell
  haskell-src: no support for precedence and associativity
  haskell-src-ext: no support for source locations

* highlight "the data (Number) that is
  currently being output" in the editor

* compositional highlighting
  The composition of note streams shall also compose their highlighting animations.
  Currently active terms are highlighted during a Wait event,
  but those Wait events are shortened by 'merge'.
  Actually, all active terms should only be highlighted
  for an infinitesimally short time.
  For music highlighting we could highlight terms from NoteOn to corresponding NoteOff.
  This would not work -
  if NoteOn is wrapped in f and NoteOff is wrapped in g,
  then on NoteOn the highlighting of f is switched on
  and on NoteOff the highlighting of g is switched off?
  Instead I think we must highlight the complete "backtrace" for the active term
  (or at least the Wait, since this is what we really show)

* merge editor and highlighter window
  track all inputs of the editor window and
  adapt the information in the syntax tree accordingly

* add a type checker to the implementation
  (and data declarations to the language)

* support different import modes, qualified identifiers
  and clashing identifiers in modules
  Only this way, several people can work independently in their modules.

* check all head, read, error, unmatched patterns, irrefutable patterns, print, putStr stderr,
  toProgram, toPitch, toVelocity,
  readFile, writeFile and other IO functions,
  whether they should handle exceptions
  especially in Program there are currently too many 'errors'
  problem: there will be no warnings about patterns in monadic results
      e.g. (Number rng n) <- top

* handle for resizing parts of the window
  even better: a way for rearranging parts of the GUI
  this would allow to arrange text fields horizontally
  such as required for wide aspect in YouTube movies

* bug: when changing a module you might remove a term,
  that is still present in the reduced term
  In this case, the highlighter will highlight its original position.
  Reproduce it by: delete the 'repeat' in Simplesong and refresh -
  the former position of merge is highlighted

* cabal test:
  check whether modules in 'data' can be parsed by our parser
  check whether modules in 'data' directory can be compiled by GHC

* default path for data files
  Option.importPaths deflt should contain the paths from the Paths module.
  This makes working with an installation from Hackage easy,
  but makes working in the GIT working copy awful,
  because after every change in data/ you have to reinstall the files.

* log to a MIDI file
  Button "Open log": open a raw file that we log into
     alternatively there should be an option '--log' for opening the file
  Button "Close log": copy the raw file into a valid MIDI file
     closing and wrapping the log should also performed at Quit
  We could also let an external program log the events,
  but then we must use ALSA time stamps for precise timing.
  We could also provide a module that interprets a static program
  and generates a MIDI file from it like Haskore.

* maybe split Term into Parser and Term module

* allow to enter lyrics
  show them in status line or in a new window
