* Module system:
  allow adding modules
  allow closing modules
  allow renaming modules:
    when reloading a module,
    check whether the name has changed and whether the name clashes with other modules,
    if rename is possible, then alter tab name
    also alter the imports of the other modules
  hierarchical module names
  if an import is added, load the module
  flush unimported modules
  qualify identifiers

* Library part
  Move modules into module hierarchy.

* pair syntax (a,b)
  We could make "," a regular infix operator with low precendence.
  This would give us operator section syntax.
  However it conflicts with commas in list syntax.

* Are newlines in module content from HTTP handled correctly?
  WWW uses CR+LF
  I have observed, that Windows/InternetExplorer submits CR+LF in the modified text lines.
  The question is, what kind of line end is expected by WxWidgets?

* higher order functions:
  support operator sections like (+) and (:)
    Can expressions like (a+) and (+b) be handled by postfix and prefix operators?
    This won't work, because operator sections are only allowed in parentheses.
    E.g. (a + + b) is not valid syntax.
    However it is allowed to write (a+b+).
    But due to the left-associativity it is not allowed to write (+a+b).
    Is it allowed to use the same operator as infix and postfix symbol?
    Maybe at the beginning I should only support (+), but not (a+) and (+a).
    Since operator section is only allowed in parentheses
       we can handle it in the parser of syntactic atoms.
  support lambda

* Gtk-CRITICAL warnings: eliminate them
  sometimes the program crashes on exit

* GUI graphical error:
  between menu and tab handles there is a short line,
    that looks like the top border of another handle
  does it have a meaning?

* precise ALSA timing
  For precise timing it is certainly better
  to send ALSA events with future time stamps.
  Currently we wait using ALSA echo events
  and then send the actual event immediately.
  The proposed change increases latency of changes in the source files.
  Current term and highlighting should be updated
  when the delayed MIDI event is played.
  We can achieve this by sending an Echo message to ourselve.

* Dirk Richter proposes to store old module contents when updating a module.
  This way you can later reproduce what you did in a live performance.

* allocate multiple ALSA ports and extend the Channel constructor by a port field
  Multiple ports allow to connect to different ALSA nodes
  and feed them with individual data.
  This is more easily done than distinction using MIDI channels.

* use haskell-src(-exts) for parsing,
  to be sure we have a subset of haskell
  haskell-src: no support for precedence and associativity
  haskell-src-ext: no support for source locations

* Can we use reactive-banana-wx in order to write safer GUI?
  Maybe we can simplify:
     mutual exclusive menu items
     consistency Map Module.Name Page with GUI pages
     synchronization of ALSA and WX and HTTP,
        e.g. various inputs to the text field; execution modes
  Peter Pepper: "Acausal programming"

* demand trace/"backtrace"/GUI:
  distinguish between musical and operational highlighting
  as described below, highlighting according to NoteOn and NoteOff won't work
  and it would also not solve the problem of dependencies
  We could maintain a map of currently played notes
     in order to switch off highlighting for these notes,
     when NoteOff is send.
     This would correctly de-highlight notes,
     but the backtrace would still be cumulative.
  Interesting observation:
     in a 'repeat' the last notes are turned back to normal appearance
     if the loop starts again

* compositional highlighting
  The composition of note streams shall also compose their highlighting animations.
  Currently active terms are highlighted during a Wait event,
  but those Wait events are shortened by 'merge'.
  Actually, all active terms should only be highlighted
  for an infinitesimally short time.
  For music highlighting we could highlight terms from NoteOn to corresponding NoteOff.
  This would not work -
  if NoteOn is wrapped in f and NoteOff is wrapped in g,
  then on NoteOn the highlighting of f is switched on
  and on NoteOff the highlighting of g is switched off?
  Instead I think we must highlight the complete "backtrace" for the active term
  (or at least the Wait, since this is what we really show)

* merge editor and highlighter window
  track all inputs of the editor window and
  adapt the information in the syntax tree accordingly
  I am not sure that this is an advantage.
  Maybe there should be two windows:
  One with the editor and one with the interpreter content and the current term.
  This way you can project the interpreter content to the wall
  and edit in the editor privately.

* Maybe we should use WxWidgets feature for external GUI description.
  This way, the user can choose the arrangement
  of editor, highlighter and current term area.
  We could also have translated versions without recompilation.

* add a type checker to the implementation
  Try to incorporate Helium/parser/type-checker or Typing Haskell in Haskell.
  Can one of the special Haskell editors Yi or Leksah be of help?

* support different import modes, qualified identifiers
  and clashing identifiers in modules
  Only this way, several people can work independently in their modules.

* check all head, read, error, unmatched patterns, irrefutable patterns, print, putStr stderr,
  toProgram, toPitch, toVelocity,
  readFile, writeFile and other IO functions,
  whether they should handle exceptions
  especially in Program there are currently too many 'errors'
  problem: there will be no warnings about patterns in monadic results
      e.g. (Number rng n) <- top

* handle for resizing parts of the window
  even better: a way for rearranging parts of the GUI
  this would allow to arrange text fields horizontally
  such as required for wide aspect in YouTube movies

* bug: when changing a module you might remove a term,
  that is still present in the reduced term
  In this case, the highlighter will highlight its original position.
  Reproduce it by: delete the 'repeat' in Simplesong and refresh -
  the former position of merge is highlighted

* cabal test:
  check whether modules in 'data' can be parsed by our parser
  check whether modules in 'data' directory can be compiled by GHC

* maybe split Term into Parser and Term module

* allow IO or restricted IO monad
    such that the live program can send the messages itself

* single step mode: allow finer steps
  For finer steps we have to break the recursion and remember the application focus.
  How to do this?
  Using a Zipper on the Term?
  Using a Map Id Node and an Id that points to the focus?
  Do not represent a focus but extend the Term tree
    such that each node contains a sequence of reductions.
    Flattening all sequences should give a sequence of term trees.
    Since the flattening is lazy,
    we can decide later what information to present to the user.
    We could even reverse steps back to the last sent event.
